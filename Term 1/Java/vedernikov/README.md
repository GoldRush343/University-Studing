---
gitea: none
include_toc: true
---

# Тесты к курсу «Основы и методология программирования»

## Домашнее задание 12. Вычисление в различных типах

Добавьте в программу, разбирающую и вычисляющую выражения трех переменных поддержку вычисления в различных типах.

1. Создайте класс expression.generic.GenericTabulator, реализующий интерфейс `expression.generic.Tabulator`:
```
    public interface Tabulator {
        Object[][][] tabulate(
            String mode, String expression,
            int x1, int x2, int y1, int y2, int z1, int z2
        ) throws Exception;
    }
```
Аргументы

| Аргумент               | Описание                                     |
| ---------------------- | -------------------------------------------- |
| mode                   | режим вычислений                             |
| expression             | вычисляемое выражение                        |
| x1, x2; y1, y2; z1, z2 | диапазоны изменения переменных, включительно |


| Режим | Тип                            |
| ----- | ------------------------------ |
| i     | int (с проверкой переполнений) |
| d     | double                         |
| bi    | BigInteger                     |

Возвращаемое значение — таблица значений функции, где R[i][j][k] соответствует x = x1 + i, y = y1 + j, z = z1 + k. Если вычисление завершилось ошибкой, в соответствующей ячейке должен быть null.

2. Доработайте интерфейс командной строки:
    - Первым аргументом командной строки программа должна принимать указание на тип, в котором будут производиться вычисления:
      
        | Опция | Вычисления      |
        | ----- | --------------- |
        | -i    | int с проверкой |
        | -d    | double          |
        | -bi   | BigInteger      |
    - Вторым аргументом командной строки программа должна принимать выражение для вычисления.
    - Программа должна выводить результаты вычисления для всех целочисленных значений переменных из диапазона −2..2.
3. Реализация не должна содержать непроверяемых преобразований типов.
4. Реализация не должна использовать аннотацию @SuppressWarnings.
5. При выполнении задания следует обратить внимание на простоту добавления новых типов и операций.

Модификации
 * *Base*
    * Класс `GenericTabulator` должен реализовывать интерфейс
      [Tabulator](java/expression/generic/Tabulator.java) и
      строить трёхмерную таблицу значений заданного выражения.
        * `mode` – режим вычислений:
           * `i` – вычисления в `int` с проверкой на переполнение;
           * `d` – вычисления в `double` без проверки на переполнение;
           * `bi` – вычисления в `BigInteger`.
        * `expression` – выражение, для которого надо построить таблицу;
        * `x1`, `x2` – минимальное и максимальное значения переменной `x` (включительно)
        * `y1`, `y2`, `z1`, `z2` – аналогично для `y` и `z`.
        * Результат: элемент `result[i][j][k]` должен содержать
          значение выражения для `x = x1 + i`, `y = y1 + j`, `z = z1 + k`.
          Если значение не определено (например, по причине переполнения),
          то соответствующий элемент должен быть равен `null`.
    * [Исходный код тестов](java/expression/generic/GenericTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
 * *4142* Дополнительно реализуйте:
    * Унарные операции:
        * `count` – число установленных битов, `count 5` равно 2.
    * Бинарные операции (минимальный приоритет):
        * `min` – минимум, `2 min 3` равно 2;
        * `max` – максимум, `2 max 3` равно 3.
    * Поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `s` – вычисления в `short` без проверки на переполнение;
        * `f` – вычисления в `float` без проверки на переполнение.
 * *4749* Дополнительно реализуйте:
    * Бинарные операции (минимальный приоритет):
        * `min` – минимум, `2 min 3` равно 2;
        * `max` – максимум, `2 max 3` равно 3.
    * Поддержку режимов:
        * `u` – вычисления в `int` без проверки на переполнение;
        * `s` – вычисления в `short` без проверки на переполнение;
        * `f` – вычисления в `float` без проверки на переполнение.


## Домашнее задание 11. Обработка ошибок

1. Добавьте в программу, вычисляющую выражения, обработку ошибок, в том числе:
   - ошибки разбора выражений;
   - ошибки вычисления выражений.

2. Для выражения `1000000*x*x*x*x*x/(x-1)` вывод программы должен иметь следующий вид:
```
   x   f  
   0   0  
   1   division by zero  
   2   32000000  
   3   121500000  
   4   341333333  
   5   overflow  
   6   overflow  
   7   overflow  
   8   overflow  
   9   overflow  
   10  overflow  
```
   Результат `division by zero` (`overflow`) означает, что в процессе вычисления произошло деление на ноль (переполнение). 

3. При выполнении задания следует обратить внимание на дизайн и обработку исключений.

4. Человеко-читаемые сообщения об ошибках должны выводиться на консоль. 

5. Программа не должна «вылетать» с исключениями (как стандартными, так и добавленными). 


Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [TripleParser](java/expression/exceptions/TripleParser.java)
    * Результат разбора должен реализовывать интерфейс
        [TripleExpression](java/expression/TripleExpression.java)
    * Нельзя использовать типы `long` и `double`
    * Нельзя использовать методы классов `Math` и `StrictMath`
    * [Исходный код тестов](java/expression/exceptions/ExceptionsTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
 * *4142*
    * Дополнительно реализуйте бинарные операции (минимальный приоритет):
        * `gcd` – НОД, `2 gcd -3` равно 1;
        * `lcm` – НОК, `2 lcm -3` равно -6.
 * *4749*
    * Дополнительно реализуйте бинарные операции (максимальный приоритет):
        * `**` – возведение в степень, `2 ** 3` равно 8;
        * `//` – логарифм, `10 // 2` равно 3.


## Домашнее задание 10. Разбор выражений

1. Доработайте предыдущее домашнее задание, так чтобы выражение строилось по записи вида:
    ```
    x * (x - 2)*x + 1
    ```

2. В записи выражения могут встречаться:
    * бинарные операции: умножение `*`, деление `/`, сложение `+` и вычитание `-`;
    * унарный минус `-`;
    * переменные `x`, `y` и `z`;
    * целочисленные константы в десятичной системе счисления, помещающиеся в 32-битный знаковый целочисленный тип;
    * круглые скобки для явного обозначения приоритета операций;
    * произвольное число пробельных символов в любом месте, не влияющее на однозначность понимания формулы (например, между операцией и переменной, но не внутри констант).

3. Приоритет операций, начиная с наивысшего:
    1. унарный минус;
    2. умножение и деление;
    3. сложение и вычитание.

4. Разбор выражений рекомендуется производить методом рекурсивного спуска.
    * Алгоритм должен работать за линейное время.
    * Лексический анализ (токенизация) не требуется.

Модификации
 * *Base*
    * Класс `ExpressionParser` должен реализовывать интерфейс
        [TripleParser](java/expression/parser/TripleParser.java)
    * Результат разбора должен реализовывать интерфейс
        [TripleExpression](java/expression/TripleExpression.java)
    * [Исходный код тестов](java/expression/parser/ParserTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
 * *4142*
    * Дополнительно реализуйте бинарные операции:
        * `&` – побитное И, приоритет меньше чем у `+` (`6 & 1 + 2` равно `6 & (1 + 2)` равно 2);
        * `^` – побитный XOR, приоритет меньше чем у `&` (`6 ^ 1 + 2` равно `6 ^ (1 + 2)` равно 5);
        * `|` – побитное ИЛИ, приоритет меньше чем у `^` (`6 | 1 + 2` равно `6 | (1 + 2)` равно 7);
 * *4749*
    * Дополнительно реализуйте бинарные операции с минимальным приоритетом:
        * `<<` – сдвиг влево (`1 << 5 + 3` равно `1 << (5 + 3)` равно 256);
        * `>>` – сдвиг вправо (`1024 >> 5 + 3` равно `1024 >> (5 + 3)` равно 4);
        * `>>>` – арифметический сдвиг вправо (`-1024 >>> 5 + 3` равно `1024 >>> (5 + 3)` равно -4);


## Домашнее задание 9. Выражения

1. Разработайте классы `Const`, `Variable`, `Add`, `Subtract`, `Multiply`, `Divide` для вычисления выражений с одной переменной в типе `int` (интерфейс `Expression`).

2. Классы должны позволять составлять выражения вида:

   ```java
   new Subtract(
       new Multiply(
           new Const(2),
           new Variable("x")
       ),
       new Const(3)
   ).evaluate(5)
   ```

   При вычислении такого выражения вместо каждой переменной подставляется значение, переданное в качестве параметра методу `evaluate`. Таким образом, результатом вычисления приведенного примера должно стать число 7.

3. Метод `toString` должен выдавать запись выражения в полноскобочной форме. Например:

   ```java
   new Subtract(
       new Multiply(
           new Const(2),
           new Variable("x")
       ),
       new Const(3)
   ).toString()
   ```

   должен выдавать `((2 * x) - 3)`.

4. Реализуйте метод `equals`, проверяющий, что два выражения совпадают. Например:

   ```java
   new Multiply(new Const(2), new Variable("x"))
       .equals(new Multiply(new Const(2), new Variable("x")))
   ```

   должно выдавать `true`, а

   ```java
   new Multiply(new Const(2), new Variable("x"))
       .equals(new Multiply(new Variable("x"), new Const(2)))
   ```

   должно выдавать `false`.

5. Для тестирования программы должен быть создан класс `Main`, который вычисляет значение выражения $x^2 - 2x + 1$, для $x$, заданного в командной строке.

6. При выполнении задания следует обратить внимание на:
   - Выделение общего интерфейса создаваемых классов.
   - Выделение абстрактного базового класса для бинарных операций.


Модификации
 * *Base*
    * Реализуйте интерфейс [Expression](java/expression/Expression.java)
    * [Исходный код тестов](java/expression/ExpressionTest.java)
        * Первый аргумент: `easy` или `hard`
        * Последующие аргументы: модификации
 * *Triple*
    * Дополнительно реализуйте поддержку выражений с тремя переменными: `x`, `y` и `z`.
      * Например, для `expr = new Subtract(new Add(new Variable("x"), new Variable("y")), new Const(1))`:
        * `expr.evaluate(2, 3, 5)` должно быть равно 4;
        * `expr.toString()` должно быть равно `((x + y) - 1)`.
    * Интерфейс/тесты [TripleExpression](java/expression/TripleExpression.java).
 * *DoubleTriple* (41, 42)
    * Сделайте модификацию *Triple* для вычислений в типе `double`.
      * Метод должен называться `evaluateD`.
      * Например, для `expr = new Subtract(new Add(new Variable("x"), new Variable("y")), new Const(1.1))`:
        * `expr.evaluateD(2.1, 3.1, 5.1)` должно быть равно 4.1;
        * `expr.toString()` должно быть равно `((x + y) - 1.1)`.
    * Интерфейс/тесты [DoubleTripleExpression](java/expression/DoubleTripleExpression.java).
 * *LongTriple* (47-49)
    * Сделайте модификацию *Triple* для вычислений в типе `long`.
      * Метод должен называться `evaluateL`.
      * Например, для `expr = new Subtract(new Add(new Variable("x"), new Variable("y")), new Const(1L))`:
        * `expr.evaluateL(2L, 3L, 5L)` должно быть равно 4;
        * `expr.toString()` должно быть равно `((x + y) - 1)`.
    * Интерфейс/тесты [LongTripleExpression](java/expression/LongTripleExpression.java).

## Домашнее задание 8. Игра m,n,k

В этом домашнем задании вы можете пользоваться кодом, написанным на лекции. 

1. Реализуйте игру [m,n,k](https://en.wikipedia.org/wiki/M%2Cn%2Ck-game) (k в ряд на доске m×n).
2. Добавьте обработку ошибок ввода пользователя (HumanPlayer). В случае ошибочного хода пользователь должен иметь возможность сделать другой ход.
3. Добавьте обработку ошибок игроков. В случае ошибки игрок автоматически проигрывает.
4. Доска должна производить обработку хода (проверку корректности, изменение состояния и определение результата) за O(k).
5. Предотвратите жульничество: у игрока не должно быть возможности достать Board из Position.
6. Код должен находиться в пакете game.

Модификации
 * *Base*
    * Тестов не существует, так как они зависят от вашего кода.

 * *Ромб*
    * Добавьте поддержку доски в форме ромба (квадрата, повернутого на 45°).
    * В качестве примера, сделайте доску размером 10×10.

 * *Double Elimination*
    * Добавьте поддержку турниров
      [с выбыванием после двух поражений](https://ru.wikipedia.org/wiki/Турнирная_система_с_выбыванием_после_двух_поражений)
      с правилом 1-2.
    * Игроки и их символы в матче выбираются случайно.
    * При ничьей игроки играют до результативной партии.
    * Выбывшие на одном круге делят одно место.
    * Если игроков не степень двойки, то часть из них проходит во второй круг без игры.

## Домашнее задание 7. Разметка

Модификации
 * *Base*
    * Исходный код тестов:
        * [MarkupTester.java](java/markup/MarkupTester.java)
        * [MarkupTest.java](java/markup/MarkupTest.java)
        * Аргументы командной строки: модификации
    * Откомпилированных тестов не существует,
      так как они зависят от вашего кода
 * *3637*, *3839*, *4142*, *4749*
    * Дополнительно реализуйте метод `toTex`, генерирующий TeX-разметку:
      * Абзацы предваряются командой `\par{}`
      * Выделенный текст заключается в `\emph{` и `}`
      * Сильно выделенный текст заключается в `\textbf{` и `}`
      * Зачеркнутый текст заключается в `\textst{` и `}`
    * Добавьте поддержку:
      * Нумерованных списков (класс `OrderedList`, окружение `enumerate`): последовательность элементов
      * Ненумерованных списков (класс `UnorderedList`, окружение `itemize`): последовательность элементов
      * Элементов списка (класс `ListItem`, тег `\item`: последовательность абзацев и списков
    * Для новых классов поддержка Markdown не требуется
    * [Исходный код тестов](java/markup/MarkupListTest.java)
 * *3233*, *3435*
    * Дополнительно реализуйте метод `toHtml`, генерирующий HTML-разметку:
      * Абзацы окружаются тегом `p`
      * Выделенный текст окружается тегом `em`
      * Сильно выделенный текст окружается тегом `strong`
      * Зачеркнутый текст окружается тегом `s`


## Домашнее задание 6. Подсчет слов++

Модификации
 * *Base*
    * Класс должен иметь имя `Wspp`
    * Исходный код тестов:
        [WsppTest.java](java/wspp/WsppTest.java),
        [WsppTester.java](java/wspp/WsppTester.java)
    * Откомпилированные тесты: [WsppTest.jar](artifacts/WsppTest.jar)
        * Аргументы командной строки: модификации
 * *3637*
    * В выходном файле слова должны быть упорядочены
      по возрастанию длины, а при равной длине –
      по порядку первого вхождения во входной файл
    * Вместо всех вхождений в файле надо указывать
      только последнее вхождение в строке
    * В словах могут дополнительно встречаться
      цифры и символы `$` и `_`
    * Класс должен иметь имя `WsppLast`
 * *3839*
    * В выходном файле слова должны быть упорядочены
      по возрастанию длины, а при равной длине –
      по порядку первого вхождения во входной файл
    * Вместо всех вхождений в файле надо указывать
      только среднее вхождение строке
    * В словах могут дополнительно встречаться
      цифры и символы `$` и `_`
    * Класс должен иметь имя `WsppMiddle`
 * *3435*
    * В выходном файле слова должны быть упорядочены
      по возрастанию длины, а при равной длине –
      по порядку первого вхождения во входной файл
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер вхождения>`,
      где номер вхождения считается с конца файла
    * В словах могут дополнительно встречаться
      цифры и символы `$` и `_`
    * Класс должен иметь имя `WsppPosition`
 * *3233*
    * В выходном файле слова должны быть упорядочены
      в порядке вхождения во входной файл
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер вхождения>`,
      где номер вхождения считается с конца файла
    * В словах могут дополнительно встречаться
      цифры и символы `$` и `_`
    * Класс должен иметь имя `WsppPos`
 * *4142*
    * В выходном файле слова должны быть упорядочены
      по возрастанию длины, а при равной длине –
      по порядку первого вхождения во входной файл
    * Вместо всех вхождений в файле надо указывать
      только последнее вхождение в строке
    * В словах могут дополнительно встречаться
      цифры и символы `$` и `_`
    * Класс должен иметь имя `WsppLast`
 * *4749*
    * В выходном файле слова должны быть упорядочены
      по возрастанию длины, а при равной длине –
      по порядку первого вхождения во входной файл
    * Вместо номеров вхождений во всем файле надо указывать
      `<номер строки>:<номер вхождения>`,
      где номер вхождения считается с конца файла
    * В словах могут дополнительно встречаться
      цифры и символы `$` и `_`
    * Класс должен иметь имя `WsppPosition`


## Домашнее задание 5. Свой сканнер

Модификации
 * *Base*
    * Исходный код тестов: [FastReverseTest.java](java/reverse/FastReverseTest.java)
    * Откомпилированные тесты: [FastReverseTest.jar](artifacts/FastReverseTest.jar)
        * Аргументы командной строки: модификации
 * *3637*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите минимум из чисел,
      находящихся в его столбце в последующих строках, и его самого
    * Во вводе могут быть десятичные и восьмиричные числа
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `ReverseMinC`
 * *3839*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите минимум из чисел
      текущее число — правый нижний угол матрицы
    * Во вводе могут быть десятичные и восьмиричные числа
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `ReverseMin`
 * *3435*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      выведите ее поворот по часовой стрелке
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `ReverseRotate`
 * *3233*
    * Выведите (в реверсивном порядке) только числа,
      у которых сумма номеров строки и столбца четная
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `ReverseEven`
 * *4142*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите среднее из чисел в его столбце и строке
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `ReverseAvg`
 * *4749*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чиселв его столбце и строке
    * Числа дополнительно могут разделяться
      [открывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#START_PUNCTUATION)
      и [закрывающими](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/lang/Character.html#END_PUNCTUATION)
      скобками
    * Класс должен иметь имя `ReverseSum`


## Домашнее задание 4. Подсчет слов

Модификации
 * *Base*
    * Класс должен иметь имя `WordStat`
    * Исходный код тестов:
        [WordStatTest.java](java/wordStat/WordStatTest.java),
        [WordStatTester.java](java/wordStat/WordStatTester.java),
        [WordStatChecker.java](java/wordStat/WordStatChecker.java)
    * Откомпилированные тесты: [WordStatTest.jar](artifacts/WordStatTest.jar)
        * Аргументы командной строки: модификации
 * *FastSort*
    * Пусть _n_ – число слов во входном файле,
      тогда программа должна работать за O(_n_ log _n_).
 * *3637*
    * Назовём _серединой слова_ подстроку, полученную удалением
      первых и последних 3 символов слова.
      Слова длины меньшей 7 игнорируются.
    * Выходной файл должен содержать все различные
      середины слов, встречающихся во входном файле,
      упорядоченные по возрастанию длины (при равенстве – по первому вхождению).
    * Класс должен иметь имя `WordStatLengthMiddle`
 * *3839*
    * Назовём _аффиксами слова_
      его префикс и суффикс длины `n / 2`, где `n` — длина слова.
      Слова длины один игнорируются.
    * Выходной файл должен содержать все различные
      аффиксы слов, встречающихся во входном файле,
      упорядоченные по возрастанию длины (при равенстве – по первому вхождению).
    * Класс должен иметь имя `WordStatLengthAffix`
 * *3435*
    * Назовём _суффиксом слова_ подстроку,
      состоящую из `n / 2` последних символов слова, где `n` — длина слова.
      Слова длины один игнорируются.
    * Выходной файл должен содержать все различные
      суффиксы слов, встречающихся во входном файле,
      упорядоченные по возрастанию длины (при равенстве – по первому вхождению).
    * Класс должен иметь имя `WordStatLengthSuffix`
 * *3233*
    * Выходной файл должен содержать все различные
      слова встречающиеся во входном файле,
      упорядоченные по возрастанию длины (при равенстве – по первому вхождению).
    * Класс должен иметь имя `WordStatLength`
 * *4142*
    * Назовём _серединой слова_ подстроку, полученную удалением
      первых и последних 3 символов слова.
      Слова длины меньшей 7 игнорируются.
    * Выходной файл должен содержать все различные
      середины слов, встречающихся во входном файле,
      упорядоченные по возрастанию длины (при равенстве – по первому вхождению).
    * Класс должен иметь имя `WordStatLengthMiddle`
 * *4749*
    * Назовём _префиксом слова_ подстроку,
      состоящую из `n / 2` первых символов слова, где `n` — длина слова.
      Слова длины один игнорируются.
    * Выходной файл должен содержать все различные
      префиксы слов, встречающихся во входном файле,
      упорядоченные по возрастанию длины (при равенстве – по первому вхождению).
    * Класс должен иметь имя `WordStatLengthPrefix`


## Домашнее задание 3. Реверс

Модификации
 * *Base*
    * Исходный код тестов:
        [ReverseTest.java](java/reverse/ReverseTest.java),
        [ReverseTester.java](java/reverse/ReverseTester.java)
    * Откомпилированные тесты: [ReverseTest.jar](artifacts/ReverseTest.jar)
        * Аргументы командной строки: модификации
 * *Memory*
    * Программа должна сначала считывать все данные в память,
      и только потом обрабатывать их.
    * Пусть _M_ – объём памяти, необходимый для сохранения ввода
      в двумерном массиве `int` минимального размера.
      Ваша программа должна использовать не более 4_M_ + 1024 байт памяти.
    * Накладные расходы на запуск вашей программы JVM не учитываются.
 * *3637*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите максимум из чисел,
      находящихся в его столбце в последующих строках, и его самого
    * Класс должен иметь имя `ReverseMaxC`
 * *3839*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите максимум из чисел
      текущее число — правый нижний угол матрицы
    * Класс должен иметь имя `ReverseMax`
 * *3435*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      выведите ее поворот по часовой стрелке, например для ввода
        ```
            1 2 3 4
            5 6
            7 8 9
        ```
      вывод должен быть
        ```
            7 5 1
            8 6 2
            9 3
            4
        ```
    * Класс должен иметь имя `ReverseRotate`
 * *3233*
    * Выведите (в реверсивном порядке) только числа,
      у которых сумма номеров строки и столбца четная
    * Класс должен иметь имя `ReverseEven`
 * *4142*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите среднее из чисел в его столбце и строке
    * Класс должен иметь имя `ReverseAvg`
 * *4749*
    * Рассмотрим входные данные как (не полностью определенную) матрицу,
      вместо каждого числа выведите сумму чиселв его столбце и строке
    * Класс должен иметь имя `ReverseSum`


## Домашнее задание 2. Сумма чисел

Модификации
 * *Base*
    * Исходный код тестов:
        [SumTest.java](java/sum/SumTest.java),
        [SumTester.java](java/sum/SumTester.java),
        [базовые классы](java/base/)
    * Откомпилированные тесты: [SumTest.jar](artifacts/SumTest.jar)
        * Аргументы командной строки: модификации
 * *3637*
    * Входные данные являются 64-битными числами в формате с плавающей точкой
    * На вход подаются десятичные и шестнадцатеричные числа
    * Шестнадцатеричные числа имеют префикс `0x`,
      например `0xa.bp2` равно (10+11/16)·4 равно 42.75
    * Ввод регистронезависим
    * Класс должен иметь имя `SumDoubleHex`
 * *3839*
    * Входные данные помещаются в тип [BigDecimal](https://docs.oracle.com/en/java/javase/21/docs/api/java.base/java/math/BigDecimal.html)
    * На вход подаются десятичные и шестнадцатеричные числа
    * Шестнадцатеричные числа имеют префикс `0x`,
      например `0xbsc` равно 11·10⁻¹²
      (мантисса и порядок являются целыми числами)
    * Ввод регистронезависим
    * Класс должен иметь имя `SumBigDecimalHex`
 * *3435*
    * На вход подаются десятичные и шестнадцатеричные числа
    * Шестнадцатеричные числа имеют префикс `0x`
    * Ввод регистронезависим
    * Класс должен иметь имя `SumHex`
 * *3233*
    * Входные данные являются 64-битными числами в формате с плавающей точкой
    * Класс должен иметь имя `SumDouble`
 * *4142*
   * Входные данные помещаются в тип [BigInteger](https://docs.oracle.com/en/java/javase/17/docs/api/java.base/java/math/BigInteger.html)
   * восьмеричные числа имеют суффикс `o`
   * Класс должен иметь имя `SumBigIntegerOctal`
 * *4749*
   * Входные данные являются 64-битными целыми числами
   * восьмеричные числа имеют суффикс `o`
   * Класс должен иметь имя `SumLongOctal`


Для того, чтобы протестировать программу:

 1. Скачайте откомпилированные тесты ([SumTest.jar](artifacts/SumTest.jar))
 1. Откомпилируйте `Sum.java`
 1. Проверьте, что создался `Sum.class`
 1. В каталоге, в котором находится `Sum.class`, выполните команду
    ```
       java -ea -jar <путь к SumTest.jar> Base
    ```
    * Например, если `SumTest.jar` находится в текущем каталоге, выполните команду
    ```
        java -ea -jar SumTest.jar Base
    ```
 1. Для ускорения отладки рекомендуется сделать скрипт, выполняющий шаги 2−4.


## Домашнее задание 1. Запусти меня!

Модификации
  * *RunMe*
    1. Скачайте исходный код [RunMe.java](java/RunMe.java).
    1. Создайте скрипт, компилирующий и запускающий `RunMe` из командной строки
       с выданными вам аргументами командной строки.
    1. Следуйте выведенной инструкции.

Рекомендации по выполнению модификации

1. Проверьте версию Java:
    1. Запустите `javac --version` и проверьте, что версия
       находится в диапазоне 21..24.
    1. Запустите `java --version` и проверьте, что версия
       такая же как и у `javac`.
1. Скачайте [RunMe.java](java/RunMe.java)
1. Откомпилируйте `RunMe.java`:
    1. Запустите `javac RunMe.java`
    1. Убедитесь, что компиляция завершилась без ошибок
    1. Проверьте, что появился `RunMe.class`
1. Запустите `RunMe`:
    1. Запустите `java RunMe [шесть] [слов] [пароля] [пришедшего] [на] [email]`
    1. При правильном исполнении вы должны получить ссылку.
       Если получено сообщение об ошибке — исправьте её и запустите повторно
    1. Зайдите по полученной ссылке и убедитесь, что она правильная
1. Напишите и протестируйте скрипт:
    1. Напишите скрипт, включающий команды компиляции и запуска.
       Если вы не умеете писать скрипты, воспользуйтесь одной из инструкций:
       [Windows](https://tutorialreference.com/batch-scripting/batch-script-files),
       [Linux](https://www.freecodecamp.org/news/shell-scripting-crash-course-how-to-write-bash-scripts-in-linux/),
       [macOS](https://rowannicholls.github.io/bash/intro/myscript.html)
    1. Запустите и проверьте, что вы получили ту же ссылку, что и в предыдущем пункте
    1. Сдайте скрипт преподавателю
1. Вы можете получить больше плюсиков, модифицируя код `RunMe.java`
